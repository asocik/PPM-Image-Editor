//
// Class that supports PPM (and other) image formats.
//
// Original Author:
//   Stephen Bogner
// Modified by:
//   Prof. Joe Hummel
// Reference:
//   http://www.codeproject.com/Articles/18968/PixelMap-Class-and-PNM-Image-Viewer
//

using System;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Imaging;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;
using Microsoft.FSharp.Collections;

using SysColor = System.Drawing.Color;
using SysRectangle = System.Drawing.Rectangle;

namespace PPMImageEditor
{
  /// <summary>
  /// This class provides a managed C# abstraction for Portable Bit Map (.pbm), Portable Grey Map (.pgm) and 
  /// Portable Pixel Map (.ppm)images.  The class is able to handle P1 (ASCII .pbm), P2 (ASCII .pgm) P3 (ASCII .ppm),
  /// P5 (binary .pgm), and P6 (binary .ppm) files and streams. P4 (binary .pbm) is not supported.  The class can 
  /// process normal images, which have widths that are multiples of 4 pixels wide, and can also handle "off-size"
  /// images using a less efficient algorithm.  It presents .pbm and .pgm images using the 8bppIndexed pixel format,
  /// and presents .ppm images using the 24bppRGB pixel format.  It can convert these images into a visually pleasing
  /// greyscale bitmap image (in a less efficient 24bppRGB pixel format), which is accessible using the GreyMap 
  /// property.
  /// </summary>
  public class PixelMap
  {
    private PixelMapHeader header;
    /// <summary>
    /// The header portion of the PixelMap.
    /// </summary>
    public PixelMapHeader Header
    {
      get { return header; }
      set { header = value; }
    }

    private byte[] rawImageData;
    /// <summary>
    /// The data portion of the PixelMap.
    /// </summary>
    public byte[] RawImageData
    {
      get { return rawImageData; }
      set { rawImageData = value; }
    }

    private FSharpList<FSharpList<int>> imageListData;
    /// <summary>
    /// The data portion of the PixelMap, in list of lists form.
    /// </summary>
    public FSharpList<FSharpList<int>> ImageListData
    {
      get
      {
        if (imageListData == null)  // first request, populate:
        {
          imageListData = FSharpList<FSharpList<int>>.Empty;

          // we have to go backwards given how list is built:
          for (int i = rawImageData.Length; i > 0; /*nop*/)
          {
            FSharpList<int> row = FSharpList<int>.Empty;

            for (int j = Stride; j > 0; j--)  // for each pixel in row:
            {
              i--;
              row = new FSharpList<int>(rawImageData[i], row);
            }

            imageListData = new FSharpList<FSharpList<int>>(row, imageListData);
          }//for
        }

        return imageListData;
      }

      set { imageListData = value; }
    }

    private PixelFormat pixelFormat;
    /// <summary>
    /// The pixel format used by the BitMap generated by this PixelMap.
    /// </summary>
    public PixelFormat PixelFormat
    {
      get { return pixelFormat; }
    }

    private int bytesPerPixel;
    /// <summary>
    /// The number of bytes per pixel.
    /// </summary>
    public int BytesPerPixel
    {
      get { return bytesPerPixel; }
    }

    private int stride;
    /// <summary>
    /// The stride of the scan across the image.  Typically this is width * bytesPerPixel, and is a multiple of 4.
    /// </summary>
    public int Stride
    {
      get { return stride; }
      set { stride = value; }
    }

    private Bitmap bitmap;
    /// <summary>
    /// The Bitmap created from the PixelMap.
    /// </summary>
    public Bitmap BitMap
    {
      get { return bitmap; }
    }

    /// <summary>
    /// File-based constructor.
    /// </summary>
    /// <param name="filename">The name of the .pbm, .pbm, or .ppm file.</param>
    public PixelMap(string filename)
    {
      if (File.Exists(filename))
      {
        FileStream stream = new FileStream(filename, FileMode.Open);
        this.FromStream(stream);
        stream.Close();
      }
      else
      {
        throw new FileNotFoundException("The file " + filename + " does not exist", filename);
      }
    }

    /// <summary>
    /// List-based constructor.
    /// </summary>
    /// <param name="rawImage">Is an F#-based list of lists, one list per row.</param>
    public PixelMap(FSharpList<FSharpList<int>> rawImage)
    {
      // format info for "P3" PPM images:
      this.pixelFormat = PixelFormat.Format24bppRgb;
      this.bytesPerPixel = 3;

      // get info for this image and store in header:
      PixelMapHeader hdr = new PixelMapHeader();
      hdr.MagicNumber = "P3";
      hdr.Depth = 255;  // we are assuming "P3" PPM image files;
      hdr.Height = rawImage.Length;  // height = # of rows of data;
      hdr.Width = rawImage.Head.Length / this.bytesPerPixel;  // width is # of PIXELS per row

      System.Diagnostics.Debug.Assert(rawImage.Head.Length % this.bytesPerPixel == 0);

      this.Header = hdr;

      // stride is # of color values per row, for P3 this is width * bytesPerPixel:
      this.stride = hdr.Width * this.bytesPerPixel;

      // allocate and initialize raw data for image:
      this.rawImageData = new byte[hdr.Height * this.stride];

      int i = 0;  // index into image data array:

      foreach (FSharpList<int> row in rawImage)
        foreach (int color in row)
          rawImageData[i++] = (byte)color;

      System.Diagnostics.Debug.Assert(i == this.rawImageData.Length);

      // create bitmap for display:
      if (this.stride % 4 == 0)
      {
        this.bitmap = CreateBitMap();
      }
      else
      {
        this.bitmap = CreateBitmapOffSize();
      }

      // finally, save this list!
      this.imageListData = rawImage;
    }

    /// <summary>
    /// Stream-based constructor. Typically, the stream will be a FileStream, but it may also be a MemoryStream
    /// or other object derived from the Stream class.
    /// </summary>
    /// <param name="stream">A stream containing the header and data portions of the .pbm, .pgm, or .ppm image.</param>
    public PixelMap(Stream stream)
    {
      this.FromStream(stream);
    }

    private void FromStream(Stream stream)
    {
      int index;
      this.header = new PixelMapHeader();
      int headerItemCount = 0;
      BinaryReader binReader = new BinaryReader(stream);
      try
      {
        //1. Read the Header.
        while (headerItemCount < 4)
        {
          char nextChar = (char)binReader.PeekChar();
          if (nextChar == '#')    // comment
          {
            while (binReader.ReadChar() != '\n') ;  // ignore the rest of the line.
          }
          else if (Char.IsWhiteSpace(nextChar))   // whitespace
          {
            binReader.ReadChar();   // ignore whitespace
          }
          else
          {
            switch (headerItemCount)
            {
              case 0: // next item is Magic Number
                // Read the first 2 characters and determine the type of pixelmap.
                char[] chars = binReader.ReadChars(2);
                this.header.MagicNumber = chars[0].ToString() + chars[1].ToString();
                headerItemCount++;
                break;
              case 1: // next item is the width.
                this.header.Width = ReadValue(binReader);
                headerItemCount++;
                break;
              case 2: // next item is the height.
                this.header.Height = ReadValue(binReader);
                headerItemCount++;
                break;
              case 3: // next item is the depth.
                if (this.header.MagicNumber == "P1" | this.header.MagicNumber == "P4")
                {
                  // no depth value for PBM type.
                  headerItemCount++;
                }
                else
                {
                  this.header.Depth = ReadValue(binReader);
                  headerItemCount++;
                }
                break;
              default:
                throw new Exception("Error parsing the file header.");
            }
          }
        }

        // 2. Read the image data.
        // 2.1 Size the imageData array to hold the image bytes.
        switch (this.header.MagicNumber)
        {
          case "P3": // 3 bytes per pixel
            this.pixelFormat = PixelFormat.Format24bppRgb;
            this.bytesPerPixel = 3;
            break;
          default:
            throw new Exception("Unknown Magic Number: " + this.header.MagicNumber);
        }

        this.rawImageData = new byte[this.header.Width * this.header.Height * this.bytesPerPixel];
        this.stride = this.header.Width * this.bytesPerPixel;

        System.Diagnostics.Debug.Assert(this.header.MagicNumber == "P3"); // ASCII Encoding
        {
          int charsLeft = (int)(binReader.BaseStream.Length - binReader.BaseStream.Position);
          char[] charData = binReader.ReadChars(charsLeft);   // read all the data into an array in one go, for efficiency.
          string valueString = string.Empty;
          index = 0;
          for (int i = 0; i < charData.Length; i++)
          {
            if (Char.IsWhiteSpace(charData[i])) // value is ignored if empty, or converted to byte and added to array otherwise.
            {
              if (valueString != string.Empty)
              {
                this.rawImageData[index] = (byte)int.Parse(valueString);
                valueString = string.Empty;
                index++;
              }
            }
            else // add the character to the end of the valueString.
            {
              valueString += charData[i];
            }
          }
        }

        // 3. Create the BitMap
        if (this.stride % 4 == 0)
        {
          this.bitmap = CreateBitMap();
        }
        else
        {
          this.bitmap = CreateBitmapOffSize();
        }
      }

      // If the end of the stream is reached before reading all of the expected values raise an exception.
      catch (EndOfStreamException e)
      {
        Console.WriteLine(e.Message);
        throw new Exception("Error reading the stream! ", e);
      }
      catch (Exception ex)
      {
        Console.WriteLine(ex.Message);
        throw new Exception("Error reading the stream! ", ex);
      }
      finally
      {
        binReader.Close();
      }
    }

    /// <summary>
    /// As it stands, the native byte order in .pbm, .pgm, and .ppm images is RGB.  We need to reverse the order
    /// into BGR as this is what is needed for 24bppRGB bitmap pixel format on Windows.  We also invert
    /// the image, i.e. first row becomes last row, second row becomes next to last row, etc.
    /// </summary>
    private byte[] ReorderRGBtoBGR_AndInvert()
    {
      byte[] tempData = new byte[this.rawImageData.Length];

      for (int i = 0; i < this.rawImageData.Length; i++)
      {
        tempData[i] = this.rawImageData[this.rawImageData.Length - 1 - i];
      }

      return tempData;
    }

    private int ReadValue(BinaryReader binReader)
    {
      string value = string.Empty;
      
      while (!Char.IsWhiteSpace((char)binReader.PeekChar()))
      {
        value += binReader.ReadChar().ToString();
      }

      binReader.ReadByte();   // get rid of the whitespace.

      return int.Parse(value);
    }

    private Bitmap CreateBitMap()
    {
      byte[] bitmapData = ReorderRGBtoBGR_AndInvert();

      IntPtr pImageData = Marshal.AllocHGlobal(bitmapData.Length);

      Marshal.Copy(bitmapData, 0, pImageData, bitmapData.Length);

      Bitmap bitmap = new Bitmap(this.header.Width, this.header.Height, this.stride, this.pixelFormat, pImageData);

      //Rotate the BitMap by 180 degrees so it is in the same orientation as the original image.
      bitmap.RotateFlip(RotateFlipType.Rotate180FlipNone);

      return bitmap;
    }

    /// <summary>
    /// This method is able to handle the process of creating Bitmaps that are not sized in widths that are multiples
    /// of 4 pixels (which is needed for the rapid drawing using the Marshal class.)  Unfortunately, this is a very slow
    /// method, since it uses SetPixel().
    /// </summary>
    /// <returns></returns>
    private Bitmap CreateBitmapOffSize()
    {
      Bitmap bitmap = new Bitmap(this.header.Width, this.header.Height, PixelFormat.Format24bppRgb);
      SysColor sysColor = new SysColor();
      int red, green, blue;
      int index;

      System.Diagnostics.Debug.Assert(this.header.MagicNumber == "P3"); // ASCII Encoding

      byte[] bitmapData = ReorderRGBtoBGR_AndInvert();

      for (int x = 0; x < this.header.Width; x++)
      {
        for (int y = 0; y < this.header.Height; y++)
        {
          index = x + y * this.header.Width;

          // this.header.MagicNumber: "P3"
          index = 3 * index;
          blue = (int)bitmapData[index];
          green = (int)bitmapData[index + 1];
          red = (int)bitmapData[index + 2];
          sysColor = SysColor.FromArgb(red, green, blue);

          bitmap.SetPixel(x, y, sysColor);
        }
      }

      //Rotate the BitMap by 180 degrees so it is in the same orientation as the original image.
      bitmap.RotateFlip(RotateFlipType.Rotate180FlipNone);

      return bitmap;
    }

    /// <summary>
    /// This struct contains the objects that are found in the header of .pbm, .pgm, and .ppm files.
    /// </summary>
    [Serializable]
    public struct PixelMapHeader
    {
      private string magicNumber;
      /// <summary>
      /// The "Magic Number" that identifies the type of Pixelmap. P1 = PBM (ASCII); P2 = PGM (ASCII); P3 = PPM (ASCII); P4 is not used;
      /// P5 = PGM (Binary); P6 = PPM (Binary).
      /// </summary>
      public string MagicNumber
      {
        get { return magicNumber; }
        set { magicNumber = value; }
      }

      private int width;
      /// <summary>
      /// The width of the image.
      /// </summary>
      public int Width
      {
        get { return width; }
        set { width = value; }
      }

      private int height;
      /// <summary>
      /// The height of the image.
      /// </summary>
      public int Height
      {
        get { return height; }
        set { height = value; }
      }

      private int depth;
      /// <summary>
      /// The depth (maximum color value in each channel) of the image.  This allows the format to represent 
      /// more than a single byte (0-255) for each color channel.
      /// </summary>
      public int Depth
      {
        get { return depth; }
        set { depth = value; }
      }
    }
  }
}
